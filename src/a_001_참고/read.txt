## Arrays.sort : 배열 오름차순 정렬
## Arrays.sort(int형 배열 또는 char형 배열)


## String을 char 배열로
char[] String형.toCharArray

for (char x : str.toCharArray()) {
    if (x == t) answer++;
}


## String형 대문자로, 소문자로
String str = str.toUpperCase()
str.toLowerCase()


## Character형 대문자로, 소문자로
char t = Character.toUpperCase(t)


## Character형 소문자인지 대문자인지 판별
boolean Character.isLowerCase(char형)


## BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
br.readLine;

import java.io.* 해야 함


## Scanner sc = new Scanner(System.in)
sc.next() // 다음 라인 읽기
sc.nextInt() // 다음 Int형 읽기
sc.nextLine()


## String str 의 n번째 인덱스의 char를 구해라
str.charAt(n)


## 아스키코드 65 ~ 90은 대문자, 97 ~ 122는 소문자
대문자와 소문자의 차이는 32 (a와 A 등)


## Integer의 최소값, 최대값
Integer.MIN_VALUE
Integer.MAX_VALUE


## String에서 문자의 인덱스를 구해라
str.indexOf("A");
while ((pos = str.indexOf(" ")) != -1) {
    …
}


## 문자열 자르기
str.substring(0, 10)


## Integer로 형변환
int n = Integer.parseInt(br.readLine())
int n = Integer.valueOf(br.readLine())


## 문자열 뒤집기
StringBuilder.reverse()
for (String x : str) {
    String tmp = new StringBuilder(x).reverse().toString();
    answer.add(tmp);
}


## 배열, 리스트에 추가하기
answer.add(tmp)
ArrayList<String> answer = new ArrayList<>();

for (String x : str) {
    String tmp = new StringBuilder(x).reverse().toString();
    answer.add(tmp);
}


## char 배열을 String으로 변환
String.valueOf(char 배열)


## Character가 알파벳인지 판별
Character.isAlphabetic(char형)


## String 받아서 좌우 바꾸기
public String solution(String str) {

    String answer = "";

    char[] c = str.toCharArray();

    int lt = 0;
    int rt = str.length() - 1;

    while(lt < rt) {

        if (!Character.isAlphabetic(c[lt])) lt++;
        else if (!Character.isAlphabetic(c[rt])) rt--;
        else {
            char tmp = c[lt];
            c[lt] = c[rt];
            c[rt] = tmp;

            lt++;
            rt--;
        }
    }

    answer = String.valueOf(c);

    return answer;
}


## BufferedReader 읽은 후에는 br.close() 해주기
Scanner sc를 읽은 후에는 sc.close() 해주기


## HashMap<Character, Integer> map = new HashMap<>()


## HashMap에 해당 키가 포함되어 있는지
if (!map.containsKey('A'))
for (char a : str.toCharArray()) {
    if (!list.contains(a)) {
        list.add(a);
        answer += a;
    }
}


## ArrayList, List, 배열에 포함되어 있는지
String형.contains(String형 문자)

ArrayList<Character> list = new ArrayList<>();

for (char a : str.toCharArray()) {
    if (!list.contains(a)) {
        list.add(a);
        answer += a;
    }
}


## 회문문자열 = 팰린드롬 : 앞에서 읽으나 뒤에서 읽으나 같은 문자열


## 대소문자 무시하고 같은 문자열인지 비교
String형.equalsIgnoreCase(String형)


## 3항 연산자
String str = answer ? "YES" : "NO"


## 길이 - 1 해주는거 까먹지 말자
Boolean answer = true;

str = str.toLowerCase();

char[] charArr = str.toCharArray();
int lt = 0;
int rt = str.length() - 1; // -1 해주는거 까먹지 말자

while (lt < rt) { // 까먹지 말자
    if (charArr[lt] != charArr[rt]) {
        answer = false;
        break;
    }

    lt++; // 까먹지 말자
    rt--; // 까먹지 말자
}


return answer ? "YES" : "NO";


## answer += 어쩌구 대신에 StringBuilder의 append 사용
 StringBuilder sb = new StringBuilder();

for (char x : str.toCharArray()) {
//            if (x >= 65 && x <= 90) System.out.println(x);
//            if (x >= 65 && x <= 90) answer += (char)(x + 32);
    if (x >= 65 && x <= 90) answer = sb.append((char)(x + 32)).toString();
//            else answer += (char)(x - 32);
    else answer = sb.append((char)(x - 32)).toString();
}


## replace는 정규식 사용 못함
replaceAll은 정규식 사용 가능

replaceAll("[^A-Z]", "")
A부터 Z까지의 문자가 아니면 빈 문자열로 치환해라

## 정규식 ^ 이거는 부정 (즉 머머가 아니면)
[^A-Z]
대문자 A부터 Z까지의 문자가 아니면

public String solution(String str) {

    String answer = "NO";

    str = str.toUpperCase().replaceAll("[^A-Z]", "");
    String tmp = new StringBuilder(str).reverse().toString();

    if (str.equals(tmp)) answer = "YES";

    return answer;
}


## 아스키코드 - Character 형 숫자 아스키코드
0(48) ~ 9(57)


## 정수형인지 판별
Character.isDigit(char형)


## x값으로 차례대로 넘어오는 문자형 숫자('0' ~ '9')를 합쳐서 10진수화 하는 방법
answer = (answer * 10) + (c - 48)


## Integer.parseInt 2진수를 10진수로
answer += (char)Integer.parseInt(tmp, 2)


## 정규식 중간에 | 를 넣자
return Integer.parseInt(str.replaceAll("[a-z]|[A-Z]", ""))


## String의 크기만큼 int 배열 생성
int[] answer = new int[str.length()]


## 최대값, 최소값 구하기
Math.max(int형, int형)
Math.min(p, answer)


## Scanner 로 입력받아 다음의 첫 문자 받기
char c = sc.next().charAt(0)


## 앞뒤공백 없애기
String형.trim()

str.trim()


## for문 큰 값으로 거꾸로 가기
for (int i = str.legnth() - 1; i >= 0; i--)

길이에서 -1 해주는거 까먹지 말자


## BufferedReader로 읽을 때 [String 공백 char] 읽는 방법
StringTokernizer st = new StringTokernizer(br.readLine())

String str = st.nextToken()
char c = st.nextToken().charAt(0)


## 스플릿 split 특정 문자로 분리하기
String arr[] = String형.split(" ")


## int형을 String으로
Integer.toString(int형)
String.valueOf(int형)


## char형으로 초기화 시는 홑따옴표로
char tmp = '';


## String형 replace 체인
String tmp = str.substring(0, 7).replace("#", "1").replace("*", "0")


## append 체인 구성
append(x).append(" ")

for (int x : t.solution(n, arr)) {
//            System.out.print(x + " ");
    result = sb.append(x).append(" ").toString();
}


## 배열, HashMap, TreeSet, List, ArrayList 출력하기
머머.toString()


## 소수인지 아닌지 판별하는 함수
public boolean isPrime(int num) {

//        System.out.println(num);

    if (num == 1) return false;

    for (int i = 2; i < num; i++) {
//            System.out.println(num + " % " + i + " : " + num % i);

        if (num % i == 0) return false;
    }

//        System.out.println("----------");

    return true;
}


## 봉우리에서 위치 상하좌우 좌표 초기화 배열
int[] dx = {-1, 0, 1, 0}; // 행
int[] dy = {0, 1, 0, -1}; // 열


## 배열 오름차순 정렬
Arrays.sort(int형, char형 배열 등)


## HashMap<Character, Integer> map = new hashMap<>()
map.put(키, 값)
int max = Integer.MIN_VALUE;
for (char key : map.keySet()) {
//            System.out.println(key + " " + map.get(key));
    if (map.get(key) > max) {
        max = map.get(key);
        answer = key;
    }
}


## HashMap에서 x키의 값을 가져오되 없으면 0을 넣어라
map.put(x, map.getOrDefault(x, 0) + 1) // +1 해주는거 까먹지 말자


## map.get(x)
x키의 값을 가져와라


## map.containsLey('A') 키가 존재하는지?


## map.size() 키의 개수를 알려줌


## map.remove('A') 특정 키를 삭제 (삭제된 키의 value 값을 리턴)


## HashMap에서 a맵과 b맵이 같은지 비교
amap.equals(bmap)
amap의 키와 밸류 = bmap 의 키와 밸류 모두 같은지 비교


## TreeSet은 중복도 제거하고 정렬까지 지원한다


## TreeSet 내림차순 정렬
TreeSet<Integer> Tset = new TreeSet<>(Collections.reverseOrder())

Collections.reverseOrder()가 없으면 기본 정렬


## TreeSet에 추가
트리셋형.add


## TreeSet에서 제거
ts.remove(143)
143을 지워라


## ts.first()
오름차순이면 제일 작은값
내림차순이면 제일 큰값 반환


## ts.last()
오름차순이면 제일 큰값
내림차순이면 제일 작은값 반환


## ts.size()
트리셋 원소의 개수


## TreeSet 트리셋은 중복제거에 많이 사용

## primitive 배열 깊은 복사
int[] tmp = arr.clone();
Arrays.sort(tmp);


## 스택은 구덩이, 큐는 가로로 양쪽이 뚫린 원통
스택은 먼저 들어간게 나중에 나오고(LIFO)
큐는 먼저 들어간게 먼저 나온다(FIFO)


## 스택에 넣는 것은 push, 빼는 것은 pop
stack.push(x)
stack.pop() -> 스택 맨 위에 있는걸 빼고 그 값을 반환

## 괄호 문제는 거의 스택 문제

## 스택이 비어있는지 확인하는 함수
stack.isEmpty();

## 스택의 i번째 값을 가져와라
stack.get(i)

## 스택의 제일 상단에 있는 값을 확인만 하는 함수
stack.peek()

## board가 2차원 배열일 때 board.length하면 행 길이, board[0].length는 열 길이

## for (char x : str) 이런 foreach문은 배열, Collection(List, Set, Map)만 된다

## 0이 아스키코드 48, '5'가 53인데 53 - 48 하면 int의 5가 된다

## 큐 queue에 값을 넣어주는건 queue.offer(x)

## 큐에서 꺼내는건 poll -> queue.poll() -> 제일 먼저 들어간 자료를 꺼낸다.

## 큐의 제일 앞에 있는 값을 꺼내지는 않고 확인만 하는 것 queue.peek()

## 큐의 사이즈 구하기 queue.size()

## 큐에 x가 있냐 없냐 -> boolean queue.contains(x)

## 큐는 생성 시 LinkedList를 사용한다 -> Queue<Integer> Q = new LinkedList<>()

## 큐가 비어있는지 확인하는 함수 : queue.isEmpty()

## 이분검색은 무조건 정렬이 먼저 되어야 한다. Arrays.sort(arr)